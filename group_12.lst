
group_12.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00000256  000002ca  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000256  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .stab         00000b64  00000000  00000000  000002cc  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      0000007c  00000000  00000000  00000e30  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <reset_v>:
   0:	1c c0       	rjmp	.+56     	; 0x3a <init>
	...

00000028 <timer1_cpt_v>:
  28:	0c 94 82 00 	jmp	0x104	; 0x104 <timer1_cpt_isr>

0000002c <timer1_compa_v>:
  2c:	0c 94 66 00 	jmp	0xcc	; 0xcc <timer1_compa_isr>
  30:	00 00       	nop
	...

00000034 <timer1_ovr_v>:
  34:	0c 94 1c 00 	jmp	0x38	; 0x38 <timer1_ovr_isr>

00000038 <timer1_ovr_isr>:
  38:	18 95       	reti

0000003a <init>:
  3a:	08 e0       	ldi	r16, 0x08	; 8
  3c:	0e bf       	out	0x3e, r16	; 62
  3e:	0f ef       	ldi	r16, 0xFF	; 255
  40:	0d bf       	out	0x3d, r16	; 61
  42:	00 e0       	ldi	r16, 0x00	; 0
  44:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
  48:	0c 94 4c 00 	jmp	0x98	; 0x98 <main>

0000004c <__ctors_end>:
  INTER_SIGNAL_BOUNDARY = 2 * MORSE_SIGNAL_BOUNDARY
  
  one_press:
    ; r28 stores bit pattern of morse signal
    ; 0x02 = one dash
    cpi r28, 0x02 
  4c:	c2 30       	cpi	r28, 0x02	; 2
    breq displayT
  4e:	a9 f0       	breq	.+42     	; 0x7a <displayT>
    
    ; 0x08 = one dot
    cpi r28, 0x08
  50:	c8 30       	cpi	r28, 0x08	; 8
    breq displayE
  52:	61 f0       	breq	.+24     	; 0x6c <displayE>
    
    
    ; If neither...
  	jmp checkSequenceNotMatched
  54:	0c 94 74 00 	jmp	0xe8	; 0xe8 <checkSequenceNotMatched>

00000058 <two_press>:
  
  two_press:
  	cpi r28, BIT_PATT_A
  58:	c3 30       	cpi	r28, 0x03	; 3
  	breq displayA
  5a:	91 f0       	breq	.+36     	; 0x80 <displayA>
  
  	cpi r28, BIT_PATT_N
  5c:	c9 30       	cpi	r28, 0x09	; 9
  	breq displayN
  5e:	99 f0       	breq	.+38     	; 0x86 <displayN>
  
  	cpi r28, BIT_PATT_M
  60:	c6 30       	cpi	r28, 0x06	; 6
  	breq displayM
  62:	b9 f0       	breq	.+46     	; 0x92 <displayM>
  
  	cpi r28, BIT_PATT_I
  64:	cc 30       	cpi	r28, 0x0C	; 12
  	breq displayI
  66:	91 f0       	breq	.+36     	; 0x8c <displayI>
  
  	jmp checkSequenceNotMatched
  68:	0c 94 74 00 	jmp	0xe8	; 0xe8 <checkSequenceNotMatched>

0000006c <displayE>:
    
  ;;; One character codes
  displayE:
    ldi r27, DISP_CHAR_E
  6c:	b7 e0       	ldi	r27, 0x07	; 7
    out PORTD, r27
  6e:	bb b9       	out	0x0b, r27	; 11
    rjmp cleanupDisplayLetter
  70:	00 c0       	rjmp	.+0      	; 0x72 <cleanupDisplayLetter>

00000072 <cleanupDisplayLetter>:
    
  cleanupDisplayLetter:
    ldi r27, DISP_DOT
  72:	b1 e0       	ldi	r27, 0x01	; 1
    out PORTC, r27
  74:	b8 b9       	out	0x08, r27	; 8
    jmp endOverflowInterruptStartNewLetter
  76:	0c 94 76 00 	jmp	0xec	; 0xec <endOverflowInterruptStartNewLetter>

0000007a <displayT>:

  displayT:
    ldi r27, DISP_CHAR_T
  7a:	bf e8       	ldi	r27, 0x8F	; 143
    out PORTD, r27
  7c:	bb b9       	out	0x0b, r27	; 11
    rjmp cleanupDisplayLetter
  7e:	f9 cf       	rjmp	.-14     	; 0x72 <cleanupDisplayLetter>

00000080 <displayA>:

  ;;; Two character codes
  displayA:
    ldi r27, DISP_CHAR_A
  80:	b9 e0       	ldi	r27, 0x09	; 9
    out PORTD, r27
  82:	bb b9       	out	0x0b, r27	; 11
    rjmp cleanupDisplayLetter
  84:	f6 cf       	rjmp	.-20     	; 0x72 <cleanupDisplayLetter>

00000086 <displayN>:

  displayN:
    ldi r27, DISP_CHAR_N
  86:	b3 ee       	ldi	r27, 0xE3	; 227
    out PORTD, r27
  88:	bb b9       	out	0x0b, r27	; 11
    rjmp cleanupDisplayLetter
  8a:	f3 cf       	rjmp	.-26     	; 0x72 <cleanupDisplayLetter>

0000008c <displayI>:

  displayI:
    ldi r27, DISP_CHAR_I
  8c:	b9 ef       	ldi	r27, 0xF9	; 249
    out PORTD, r27
  8e:	bb b9       	out	0x0b, r27	; 11
    rjmp cleanupDisplayLetter
  90:	f0 cf       	rjmp	.-32     	; 0x72 <cleanupDisplayLetter>

00000092 <displayM>:

  displayM:
    ldi r27, DISP_CHAR_M
  92:	b1 e3       	ldi	r27, 0x31	; 49
    out PORTD, r27
  94:	bb b9       	out	0x0b, r27	; 11
    rjmp cleanupDisplayLetter
  96:	ed cf       	rjmp	.-38     	; 0x72 <cleanupDisplayLetter>

00000098 <main>:

.global main 		; declaring main global, so it can be used in other files

main:

	call test_display
  98:	0e 94 c4 00 	call	0x188	; 0x188 <test_display>

	;;; Switch on button as input (not pressed = 1, pressed = 0)
	cbi DDRB, BUTTON
  9c:	20 98       	cbi	0x04, 0	; 4
	sbi PORTB, BUTTON
  9e:	28 9a       	sbi	0x05, 0	; 5
	sbi DDRC, 5
  a0:	3d 9a       	sbi	0x07, 5	; 7

	;;; Set output of 7 segment
	ldi r16, DISP_ALL
  a2:	0e ef       	ldi	r16, 0xFE	; 254
	out DDRD, r16
  a4:	0a b9       	out	0x0a, r16	; 10

	ldi r16, DISP_DOT
  a6:	01 e0       	ldi	r16, 0x01	; 1
	out DDRC, r16
  a8:	07 b9       	out	0x07, r16	; 7

	;;; Initialise timer1 control register
	;;; Also enable input capture, overflow interrupts for timer1
	clr r18
  aa:	22 27       	eor	r18, r18
	sts TCCR1A, r18
  ac:	20 93 80 00 	sts	0x0080, r18	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
	ldi r18, _BV(OCIE1A) | _BV(ICIE1)
  b0:	22 e2       	ldi	r18, 0x22	; 34
	sts TIMSK1, r18
  b2:	20 93 6f 00 	sts	0x006F, r18	; 0x80006f <__TEXT_REGION_LENGTH__+0x7e006f>

	call setup_timer1	;setting the timer reset limit, and resetting
  b6:	0e 94 bb 00 	call	0x176	; 0x176 <setup_timer1>

	;;; Enable noise-cancelling and set prescaler properly
	ldi r18, _BV(ICNC1) | _BV(CS12) | _BV(WGM12) | _BV(CS10)
  ba:	2d e8       	ldi	r18, 0x8D	; 141
	sts TCCR1B, r18
  bc:	20 93 81 00 	sts	0x0081, r18	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>

	; Clear timer1 overflow register, just in case
	clr r22
  c0:	66 27       	eor	r22, r22
	clr r27
  c2:	bb 27       	eor	r27, r27
	clr r28
  c4:	cc 27       	eor	r28, r28
	clr r29
  c6:	dd 27       	eor	r29, r29

	; Global Interrupt Enable
	sei
  c8:	78 94       	sei

000000ca <interrupt_loop>:

;;; Wait for interrupts
interrupt_loop:
	rjmp interrupt_loop
  ca:	ff cf       	rjmp	.-2      	; 0xca <interrupt_loop>

000000cc <timer1_compa_isr>:
.global timer1_compa_isr

;;; Timer1 has reached OCR1AH
timer1_compa_isr:

	push r16
  cc:	0f 93       	push	r16
	in r16, SREG
  ce:	0f b7       	in	r16, 0x3f	; 63
	push r16
  d0:	0f 93       	push	r16
	push r27
  d2:	bf 93       	push	r27
	
	ldi r16, TCCR1B
  d4:	01 e8       	ldi	r16, 0x81	; 129
	tst r29
  d6:	dd 23       	and	r29, r29
	sbrs r16, ICES1
  d8:	06 ff       	sbrs	r16, 6
	brne checkSequence
  da:	11 f4       	brne	.+4      	; 0xe0 <checkSequence>
	; Otherwise just reset display to ready state
	rcall ready_display
  dc:	60 d0       	rcall	.+192    	; 0x19e <ready_display>

	;;; Cleanup and end timer1_compa_isr
	rjmp endOverflowInterrupt
  de:	08 c0       	rjmp	.+16     	; 0xf0 <endOverflowInterrupt>

000000e0 <checkSequence>:

checkSequence:
	
	cpi r29, 0x01
  e0:	d1 30       	cpi	r29, 0x01	; 1
	breq onePress
  e2:	61 f0       	breq	.+24     	; 0xfc <onePress>

	cpi r29, 0x02
  e4:	d2 30       	cpi	r29, 0x02	; 2
	breq twoPress
  e6:	61 f0       	breq	.+24     	; 0x100 <twoPress>

000000e8 <checkSequenceNotMatched>:
	
; checkSequence falls through to this if nothing matches
.global checkSequenceNotMatched
checkSequenceNotMatched:
	rcall error_display
  e8:	56 d0       	rcall	.+172    	; 0x196 <error_display>
	rjmp endOverflowInterruptStartNewLetter
  ea:	00 c0       	rjmp	.+0      	; 0xec <endOverflowInterruptStartNewLetter>

000000ec <endOverflowInterruptStartNewLetter>:

.global endOverflowInterruptStartNewLetter
endOverflowInterruptStartNewLetter:

	;;; Reset r28, r29 because we want a new letter now
	clr r28
  ec:	cc 27       	eor	r28, r28
	clr r29
  ee:	dd 27       	eor	r29, r29

000000f0 <endOverflowInterrupt>:

;;; Fall through to this
endOverflowInterrupt:
	pop r27
  f0:	bf 91       	pop	r27
	pop r16
  f2:	0f 91       	pop	r16
	out SREG, r16
  f4:	0f bf       	out	0x3f, r16	; 63
	pop r16
  f6:	0f 91       	pop	r16
	
	;;; Set timer overflow register (r22)
	ser r22
  f8:	6f ef       	ldi	r22, 0xFF	; 255
	reti
  fa:	18 95       	reti

000000fc <onePress>:
	
onePress:
	jmp one_press 
  fc:	0c 94 26 00 	jmp	0x4c	; 0x4c <__ctors_end>

00000100 <twoPress>:
	
twoPress:
	jmp two_press
 100:	0c 94 2c 00 	jmp	0x58	; 0x58 <two_press>

00000104 <timer1_cpt_isr>:

.global timer1_cpt_isr
; Handle button input event
timer1_cpt_isr:
	; Save SREG
	push r8
 104:	8f 92       	push	r8
	in r8, SREG
 106:	8f b6       	in	r8, 0x3f	; 63
	push r8
 108:	8f 92       	push	r8

	; Save input capture timer to r8
	lds r8, ICR1L
 10a:	80 90 86 00 	lds	r8, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
	lds r8, ICR1H
 10e:	80 90 87 00 	lds	r8, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>

	;; Debounce Button

	push r17
 112:	1f 93       	push	r17

	mov r17, r23
 114:	17 2f       	mov	r17, r23
	or r17, r8
 116:	18 29       	or	r17, r8

	breq debounce
 118:	91 f0       	breq	.+36     	; 0x13e <debounce>

	pop r17
 11a:	1f 91       	pop	r17

	; Check for rising or falling edge
	push r17
 11c:	1f 93       	push	r17
	lds r17, TCCR1B
 11e:	10 91 81 00 	lds	r17, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
	; skip next if rising edge (ICES=1 for rising, ICES=0 for falling)
	sbrs r17, ICES1
 122:	16 ff       	sbrs	r17, 6
	; skip pressed if button is released
	rjmp pressed
 124:	04 c0       	rjmp	.+8      	; 0x12e <pressed>
	sbrc r17, ICES1
 126:	16 fd       	sbrc	r17, 6
	rcall released
 128:	0f d0       	rcall	.+30     	; 0x148 <released>


	andi r17, ~(_BV(ICES1))
 12a:	1f 7b       	andi	r17, 0xBF	; 191

	rjmp invertEdgeDetection
 12c:	01 c0       	rjmp	.+2      	; 0x130 <invertEdgeDetection>

0000012e <pressed>:

pressed:

	ori r17, _BV(ICES1)	; expects next button change to be rising edge
 12e:	10 64       	ori	r17, 0x40	; 64

00000130 <invertEdgeDetection>:

invertEdgeDetection:
	sts TCCR1B, r17
 130:	10 93 81 00 	sts	0x0081, r17	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>

00000134 <end_timer1_cpt_isr>:

end_timer1_cpt_isr:
	pop r17
 134:	1f 91       	pop	r17
	pop r8
 136:	8f 90       	pop	r8
	out SREG, r8
 138:	8f be       	out	0x3f, r8	; 63
	pop r8
 13a:	8f 90       	pop	r8
	reti
 13c:	18 95       	reti

0000013e <debounce>:

debounce:

	pop r17
 13e:	1f 91       	pop	r17
	pop r8
 140:	8f 90       	pop	r8
	out SREG, r8
 142:	8f be       	out	0x3f, r8	; 63
	pop r8
 144:	8f 90       	pop	r8

	reti
 146:	18 95       	reti

00000148 <released>:

released:

	push r16
 148:	0f 93       	push	r16
	push r27
 14a:	bf 93       	push	r27

	inc r29			; increment the button press counter
 14c:	d3 95       	inc	r29

	ldi r16, MORSE_SIGNAL_BOUNDARY ; testing whether dot or dash
 14e:	0c e0       	ldi	r16, 0x0C	; 12
	cp r8,r16
 150:	80 16       	cp	r8, r16
	brcs short_press		; if dot (short press) jump to short_press
 152:	28 f0       	brcs	.+10     	; 0x15e <short_press>
	brcc long_press
 154:	00 f4       	brcc	.+0      	; 0x156 <long_press>

00000156 <long_press>:

long_press:

	;; here store that the press was a dash
	inc r28
 156:	c3 95       	inc	r28
	lsl r28
 158:	cc 0f       	add	r28, r28

	; display T for now
	; Set pins, reset the timer and return to ISR
	rcall reset_timer1
 15a:	28 d0       	rcall	.+80     	; 0x1ac <reset_timer1>
	rjmp returnFromPressed
 15c:	08 c0       	rjmp	.+16     	; 0x16e <returnFromPressed>

0000015e <short_press>:


short_press:
	;; here store that the press was a dot
	inc r28
 15e:	c3 95       	inc	r28
	lsr r28
 160:	c6 95       	lsr	r28
	
	cpi r28, 0x08
 162:	c8 30       	cpi	r28, 0x08	; 8
	breq test
 164:	11 f0       	breq	.+4      	; 0x16a <test>

	rcall reset_timer1
 166:	22 d0       	rcall	.+68     	; 0x1ac <reset_timer1>
	rjmp returnFromPressed
 168:	02 c0       	rjmp	.+4      	; 0x16e <returnFromPressed>

0000016a <test>:
	
test:
	sbi PORTC, 5
 16a:	45 9a       	sbi	0x08, 5	; 8
	rcall reset_timer1
 16c:	1f d0       	rcall	.+62     	; 0x1ac <reset_timer1>

0000016e <returnFromPressed>:

returnFromPressed:
	pop r27
 16e:	bf 91       	pop	r27
	pop r16
 170:	0f 91       	pop	r16
	; reset timer overflow, set timer to zero
	clr r22
 172:	66 27       	eor	r22, r22
	; Going back to ISR
	ret
 174:	08 95       	ret

00000176 <setup_timer1>:

;;; Call this when a morse signal is received, to reset the timeout
setup_timer1:
	push r19
 176:	3f 93       	push	r19

	;;; Set the timer1 high byte to the inter-signal timeout (400ms)
	;;; So load it with 400/16 ~= 25 (in hex)
	ldi r19, 0x19
 178:	39 e1       	ldi	r19, 0x19	; 25
	sts OCR1AH, r19
 17a:	30 93 89 00 	sts	0x0089, r19	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>

	;;; Store zero in timer1 low byte
	clr r19
 17e:	33 27       	eor	r19, r19
	sts OCR1AL, r19
 180:	30 93 88 00 	sts	0x0088, r19	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
	pop r19
 184:	3f 91       	pop	r19
	ret
 186:	08 95       	ret

00000188 <test_display>:

test_display:
	push r21
 188:	5f 93       	push	r21

	ldi r21, ~(DISP_ALL)
 18a:	51 e0       	ldi	r21, 0x01	; 1
	out PORTD, r21
 18c:	5b b9       	out	0x0b, r21	; 11
	ldi r21, ~(DISP_DOT)
 18e:	5e ef       	ldi	r21, 0xFE	; 254
	out PORTC, r21
 190:	58 b9       	out	0x08, r21	; 8

	pop r21
 192:	5f 91       	pop	r21
	ret
 194:	08 95       	ret

00000196 <error_display>:
	
error_display:
	; Set top, middle and bottom segment of display to ON (segments A G D)
	cbi PORTD, DISP_A
 196:	5f 98       	cbi	0x0b, 7	; 11
	cbi PORTD, DISP_G
 198:	5e 98       	cbi	0x0b, 6	; 11
	cbi PORTD, DISP_D
 19a:	5b 98       	cbi	0x0b, 3	; 11
	ret
 19c:	08 95       	ret

0000019e <ready_display>:

ready_display:
	push r21
 19e:	5f 93       	push	r21

	;;; Inverse logic
	;;; Turn everything off except dot
	ldi r21, DISP_ALL
 1a0:	5e ef       	ldi	r21, 0xFE	; 254
	out PORTD, r21
 1a2:	5b b9       	out	0x0b, r21	; 11
	ldi r21, ~(DISP_DOT)
 1a4:	5e ef       	ldi	r21, 0xFE	; 254
	out PORTC, r21
 1a6:	58 b9       	out	0x08, r21	; 8

	pop r21
 1a8:	5f 91       	pop	r21
	ret
 1aa:	08 95       	ret

000001ac <reset_timer1>:

reset_timer1:

	push r17
 1ac:	1f 93       	push	r17

	clr r17			; setting timer back to 0
 1ae:	11 27       	eor	r17, r17
	sts TCNT1H, r17		; high bit
 1b0:	10 93 85 00 	sts	0x0085, r17	; 0x800085 <__TEXT_REGION_LENGTH__+0x7e0085>
	sts TCNT1L, r17		; low bit
 1b4:	10 93 84 00 	sts	0x0084, r17	; 0x800084 <__TEXT_REGION_LENGTH__+0x7e0084>

	pop r17
 1b8:	1f 91       	pop	r17
	ret
 1ba:	08 95       	ret

000001bc <displayDigit>:
 1bc:	ef 93       	push	r30
 1be:	ff 93       	push	r31
 1c0:	5f 70       	andi	r21, 0x0F	; 15
 1c2:	e2 ee       	ldi	r30, 0xE2	; 226
 1c4:	f1 e0       	ldi	r31, 0x01	; 1
 1c6:	e5 e0       	ldi	r30, 0x05	; 5
 1c8:	f2 e0       	ldi	r31, 0x02	; 2
 1ca:	e7 0f       	add	r30, r23
 1cc:	40 f4       	brcc	.+16     	; 0x1de <loadBitPatternTableToMemory>
 1ce:	f3 95       	inc	r31
 1d0:	e5 0f       	add	r30, r21
 1d2:	08 f4       	brcc	.+2      	; 0x1d6 <loadTableToMemory>
 1d4:	f3 95       	inc	r31

000001d6 <loadTableToMemory>:
 1d6:	54 91       	lpm	r21, Z
 1d8:	ff 91       	pop	r31
 1da:	ef 91       	pop	r30
 1dc:	08 95       	ret

000001de <loadBitPatternTableToMemory>:
 1de:	74 91       	lpm	r23, Z
 1e0:	08 95       	ret

000001e2 <characterCodes>:
 1e2:	40 f8       	bld	r4, 0
 1e4:	24 30       	cpi	r18, 0x04	; 4
 1e6:	98 12       	cpse	r9, r24
 1e8:	22 78       	andi	r18, 0x82	; 130
 1ea:	00 18       	sub	r0, r0
 1ec:	09 83       	std	Y+1, r16	; 0x01
 1ee:	47 a1       	ldd	r20, Z+39	; 0x27
 1f0:	07 0f       	add	r16, r23
 1f2:	03 8b       	std	Z+19, r16	; 0x13
 1f4:	f9 51       	subi	r31, 0x19	; 25
 1f6:	89 c7       	rjmp	.+3858   	; 0x110a <__FUSE_REGION_LENGTH__+0xd0a>
 1f8:	31 e3       	ldi	r19, 0x31	; 49
 1fa:	41 0d       	add	r20, r1
 1fc:	19 af       	std	Y+57, r17	; 0x39
 1fe:	19 8f       	std	Y+25, r17	; 0x19
 200:	c1 07       	cpc	r28, r17
 202:	ad 91       	ld	r26, X+	; undefined
 204:	29 10       	Address 0x0000000000000204 is out of bounds.
.word	0xffff	; ????

00000205 <characterBitpatterns>:
 205:	10 20       	and	r1, r0
 207:	00 30       	cpi	r16, 0x00	; 0

00000209 <one_press>:
    cpi r28, 0x02 
 209:	c2 30       	cpi	r28, 0x02	; 2
    breq displayT
 20b:	a9 f0       	breq	.+42     	; 0x237 <displayT>
    cpi r28, 0x08
 20d:	c8 30       	cpi	r28, 0x08	; 8
    breq displayE
 20f:	61 f0       	breq	.+24     	; 0x229 <displayE>
  	jmp checkSequenceNotMatched
 211:	0c 94 74 00 	jmp	0xe8	; 0xe8 <checkSequenceNotMatched>

00000215 <two_press>:
  	cpi r28, BIT_PATT_A
 215:	c3 30       	cpi	r28, 0x03	; 3
  	breq displayA
 217:	91 f0       	breq	.+36     	; 0x23d <displayA>
  	cpi r28, BIT_PATT_N
 219:	c9 30       	cpi	r28, 0x09	; 9
  	breq displayN
 21b:	99 f0       	breq	.+38     	; 0x243 <displayN>
  	cpi r28, BIT_PATT_M
 21d:	c6 30       	cpi	r28, 0x06	; 6
  	breq displayM
 21f:	b9 f0       	breq	.+46     	; 0x24f <displayM>
  	cpi r28, BIT_PATT_I
 221:	cc 30       	cpi	r28, 0x0C	; 12
  	breq displayI
 223:	91 f0       	breq	.+36     	; 0x249 <displayI>
  	jmp checkSequenceNotMatched
 225:	0c 94 74 00 	jmp	0xe8	; 0xe8 <checkSequenceNotMatched>

00000229 <displayE>:
    ldi r27, DISP_CHAR_E
 229:	b7 e0       	ldi	r27, 0x07	; 7
    out PORTD, r27
 22b:	bb b9       	out	0x0b, r27	; 11
    rjmp cleanupDisplayLetter
 22d:	00 c0       	rjmp	.+0      	; 0x22f <cleanupDisplayLetter>

0000022f <cleanupDisplayLetter>:
    ldi r27, DISP_DOT
 22f:	b1 e0       	ldi	r27, 0x01	; 1
    out PORTC, r27
 231:	b8 b9       	out	0x08, r27	; 8
    jmp endOverflowInterruptStartNewLetter
 233:	0c 94 76 00 	jmp	0xec	; 0xec <endOverflowInterruptStartNewLetter>

00000237 <displayT>:
    ldi r27, DISP_CHAR_T
 237:	bf e8       	ldi	r27, 0x8F	; 143
    out PORTD, r27
 239:	bb b9       	out	0x0b, r27	; 11
    rjmp cleanupDisplayLetter
 23b:	f9 cf       	rjmp	.-14     	; 0x22f <cleanupDisplayLetter>

0000023d <displayA>:
    ldi r27, DISP_CHAR_A
 23d:	b9 e0       	ldi	r27, 0x09	; 9
    out PORTD, r27
 23f:	bb b9       	out	0x0b, r27	; 11
    rjmp cleanupDisplayLetter
 241:	f6 cf       	rjmp	.-20     	; 0x22f <cleanupDisplayLetter>

00000243 <displayN>:
    ldi r27, DISP_CHAR_N
 243:	b3 ee       	ldi	r27, 0xE3	; 227
    out PORTD, r27
 245:	bb b9       	out	0x0b, r27	; 11
    rjmp cleanupDisplayLetter
 247:	f3 cf       	rjmp	.-26     	; 0x22f <cleanupDisplayLetter>

00000249 <displayI>:
    ldi r27, DISP_CHAR_I
 249:	b9 ef       	ldi	r27, 0xF9	; 249
    out PORTD, r27
 24b:	bb b9       	out	0x0b, r27	; 11
    rjmp cleanupDisplayLetter
 24d:	f0 cf       	rjmp	.-32     	; 0x22f <cleanupDisplayLetter>

0000024f <displayM>:
    ldi r27, DISP_CHAR_M
 24f:	b1 e3       	ldi	r27, 0x31	; 49
    out PORTD, r27
 251:	bb b9       	out	0x0b, r27	; 11
    rjmp cleanupDisplayLetter
 253:	ed cf       	rjmp	.-38     	; 0x22f <cleanupDisplayLetter>
	...
